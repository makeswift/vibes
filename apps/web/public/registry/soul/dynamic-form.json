{
  "name": "dynamic-form",
  "type": "registry:ui",
  "dependencies": [
    "@conform-to/react",
    "@conform-to/zod",
    "zod"
  ],
  "registryDependencies": [
    "button",
    "button-radio-group",
    "card-radio-group",
    "checkbox",
    "checkbox-group",
    "date-picker",
    "form-status",
    "input",
    "number-input",
    "radio-group",
    "select",
    "swatch-radio-group",
    "textarea"
  ],
  "files": [
    {
      "path": "vibes/soul/form/dynamic-form/index.tsx",
      "content": "/* eslint-disable complexity */\n'use client';\n\nimport {\n  FieldMetadata,\n  FormProvider,\n  getFormProps,\n  getInputProps,\n  SubmissionResult,\n  useForm,\n  useInputControl,\n} from '@conform-to/react';\nimport { getZodConstraint, parseWithZod } from '@conform-to/zod';\nimport { MouseEvent, ReactNode, startTransition, useActionState } from 'react';\nimport { useFormStatus } from 'react-dom';\nimport { z } from 'zod';\n\nimport { ButtonRadioGroup } from '@/vibes/soul/form/button-radio-group';\nimport { CardRadioGroup } from '@/vibes/soul/form/card-radio-group';\nimport { Checkbox } from '@/vibes/soul/form/checkbox';\nimport { CheckboxGroup } from '@/vibes/soul/form/checkbox-group';\nimport { DatePicker } from '@/vibes/soul/form/date-picker';\nimport { FormStatus } from '@/vibes/soul/form/form-status';\nimport { Input } from '@/vibes/soul/form/input';\nimport { NumberInput } from '@/vibes/soul/form/number-input';\nimport { RadioGroup } from '@/vibes/soul/form/radio-group';\nimport { Select } from '@/vibes/soul/form/select';\nimport { SwatchRadioGroup } from '@/vibes/soul/form/swatch-radio-group';\nimport { Textarea } from '@/vibes/soul/form/textarea';\nimport { Button, ButtonProps } from '@/vibes/soul/primitives/button';\n\nimport { Field, FieldGroup, schema } from './schema';\n\ntype Action<S, P> = (state: Awaited<S>, payload: P) => S | Promise<S>;\n\ninterface State<F extends Field> {\n  fields: Array<F | FieldGroup<F>>;\n  lastResult: SubmissionResult | null;\n}\n\nexport type DynamicFormAction<F extends Field> = Action<State<F>, FormData>;\n\nexport interface DynamicFormProps<F extends Field> {\n  fields: Array<F | FieldGroup<F>>;\n  action: DynamicFormAction<F>;\n  buttonSize?: ButtonProps['size'];\n  cancelLabel?: string;\n  submitLabel?: string;\n  submitName?: string;\n  submitValue?: string;\n  onCancel?: (e: MouseEvent<HTMLButtonElement>) => void;\n}\n\nexport function DynamicForm<F extends Field>({\n  action,\n  fields: defaultFields,\n  buttonSize = 'medium',\n  cancelLabel = 'Cancel',\n  submitLabel = 'Submit',\n  submitName,\n  submitValue,\n  onCancel,\n}: DynamicFormProps<F>) {\n  const [{ lastResult, fields }, formAction] = useActionState(action, {\n    fields: defaultFields,\n    lastResult: null,\n  });\n  const dynamicSchema = schema(fields);\n  const defaultValue = fields\n    .flatMap((f) => (Array.isArray(f) ? f : [f]))\n    .reduce<z.infer<typeof dynamicSchema>>(\n      (acc, field) => ({\n        ...acc,\n        [field.name]: 'defaultValue' in field ? field.defaultValue : '',\n      }),\n      {},\n    );\n  const [form, formFields] = useForm({\n    lastResult,\n    constraint: getZodConstraint(dynamicSchema),\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema: dynamicSchema });\n    },\n    defaultValue,\n    shouldValidate: 'onSubmit',\n    shouldRevalidate: 'onInput',\n    onSubmit(event, { formData }) {\n      event.preventDefault();\n\n      startTransition(() => {\n        formAction(formData);\n      });\n    },\n  });\n\n  return (\n    <FormProvider context={form.context}>\n      <form {...getFormProps(form)} action={formAction}>\n        <div className=\"space-y-6\">\n          {fields.map((field, index) => {\n            if (Array.isArray(field)) {\n              return (\n                <div className=\"flex gap-4\" key={index}>\n                  {field.map((f) => {\n                    const groupFormField = formFields[f.name];\n\n                    if (!groupFormField) return null;\n\n                    return (\n                      <DynamicFormField\n                        field={f}\n                        formField={groupFormField}\n                        key={groupFormField.id}\n                      />\n                    );\n                  })}\n                </div>\n              );\n            }\n\n            const formField = formFields[field.name];\n\n            if (formField == null) return null;\n\n            return <DynamicFormField field={field} formField={formField} key={formField.id} />;\n          })}\n          <div className=\"flex gap-1 pt-3\">\n            {onCancel && (\n              <Button\n                aria-label={`${cancelLabel} ${submitLabel}`}\n                onClick={onCancel}\n                size={buttonSize}\n                variant=\"tertiary\"\n              >\n                {cancelLabel}\n              </Button>\n            )}\n            <SubmitButton name={submitName} size={buttonSize} value={submitValue}>\n              {submitLabel}\n            </SubmitButton>\n          </div>\n          {form.errors?.map((error, index) => (\n            <FormStatus key={index} type=\"error\">\n              {error}\n            </FormStatus>\n          ))}\n        </div>\n      </form>\n    </FormProvider>\n  );\n}\n\nfunction SubmitButton({\n  children,\n  name,\n  value,\n  size,\n}: {\n  children: ReactNode;\n  name?: string;\n  value?: string;\n  size: ButtonProps['size'];\n}) {\n  const { pending } = useFormStatus();\n\n  return (\n    <Button loading={pending} name={name} size={size} type=\"submit\" value={value}>\n      {children}\n    </Button>\n  );\n}\n\nfunction DynamicFormField({\n  field,\n  formField,\n}: {\n  field: Field;\n  formField: FieldMetadata<string | string[] | number | boolean | Date | undefined>;\n}) {\n  const controls = useInputControl(formField);\n\n  switch (field.type) {\n    case 'number':\n      return (\n        <NumberInput\n          {...getInputProps(formField, { type: 'number' })}\n          decrementLabel={field.decrementLabel}\n          defaultValue={field.defaultValue}\n          errors={formField.errors}\n          incrementLabel={field.incrementLabel}\n          key={field.name}\n          label={field.label}\n          placeholder={field.placeholder}\n        />\n      );\n\n    case 'text':\n      return (\n        <Input\n          {...getInputProps(formField, { type: 'text' })}\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          placeholder={field.placeholder}\n        />\n      );\n\n    case 'textarea':\n      return (\n        <Textarea\n          {...getInputProps(formField, { type: 'text' })}\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          placeholder={field.placeholder}\n        />\n      );\n\n    case 'password':\n    case 'confirm-password':\n      return (\n        <Input\n          {...getInputProps(formField, { type: 'password' })}\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          placeholder={field.placeholder}\n        />\n      );\n\n    case 'email':\n      return (\n        <Input\n          {...getInputProps(formField, { type: 'email' })}\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          placeholder={field.placeholder}\n        />\n      );\n\n    case 'checkbox':\n      return (\n        <Checkbox\n          defaultValue={field.defaultValue}\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          name={formField.name}\n          onBlur={controls.blur}\n          onCheckedChange={(value) => controls.change(String(value))}\n          onFocus={controls.focus}\n          required={formField.required}\n          value={controls.value}\n        />\n      );\n\n    case 'checkbox-group':\n      return (\n        <CheckboxGroup\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          name={formField.name}\n          onValueChange={controls.change}\n          options={field.options}\n          value={Array.isArray(controls.value) ? controls.value : []}\n        />\n      );\n\n    case 'select':\n      return (\n        <Select\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          name={formField.name}\n          onBlur={controls.blur}\n          onFocus={controls.focus}\n          onValueChange={controls.change}\n          options={field.options}\n          required={formField.required}\n          value={typeof controls.value === 'string' ? controls.value : ''}\n        />\n      );\n\n    case 'radio-group':\n      return (\n        <RadioGroup\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          name={formField.name}\n          onBlur={controls.blur}\n          onFocus={controls.focus}\n          onValueChange={controls.change}\n          options={field.options}\n          required={formField.required}\n          value={typeof controls.value === 'string' ? controls.value : ''}\n        />\n      );\n\n    case 'swatch-radio-group':\n      return (\n        <SwatchRadioGroup\n          errors={formField.errors}\n          id={formField.id}\n          key={field.name}\n          label={field.label}\n          name={formField.name}\n          onBlur={controls.blur}\n          onFocus={controls.focus}\n          onValueChange={controls.change}\n          options={field.options}\n          required={formField.required}\n          value={typeof controls.value === 'string' ? controls.value : ''}\n        />\n      );\n\n    case 'card-radio-group':\n      return (\n        <CardRadioGroup\n          errors={formField.errors}\n          id={formField.id}\n          key={field.name}\n          label={field.label}\n          name={formField.name}\n          onBlur={controls.blur}\n          onFocus={controls.focus}\n          onValueChange={controls.change}\n          options={field.options}\n          required={formField.required}\n          value={typeof controls.value === 'string' ? controls.value : ''}\n        />\n      );\n\n    case 'button-radio-group':\n      return (\n        <ButtonRadioGroup\n          errors={formField.errors}\n          id={formField.id}\n          key={field.name}\n          label={field.label}\n          name={formField.name}\n          onBlur={controls.blur}\n          onFocus={controls.focus}\n          onValueChange={controls.change}\n          options={field.options}\n          required={formField.required}\n          value={typeof controls.value === 'string' ? controls.value : ''}\n        />\n      );\n\n    case 'date':\n      return (\n        <DatePicker\n          defaultValue={field.defaultValue}\n          disabledDays={\n            field.minDate != null && field.maxDate != null\n              ? {\n                  before: new Date(field.minDate),\n                  after: new Date(field.maxDate),\n                }\n              : undefined\n          }\n          errors={formField.errors}\n          key={field.name}\n          label={field.label}\n          name={formField.name}\n          onBlur={controls.blur}\n          onFocus={controls.focus}\n          onSelect={(date) =>\n            controls.change(date ? Intl.DateTimeFormat().format(date) : undefined)\n          }\n          required={formField.required}\n          selected={typeof controls.value === 'string' ? new Date(controls.value) : undefined}\n        />\n      );\n  }\n}\n",
      "type": "registry:ui",
      "target": "vibes/soul/form/dynamic-form/index.tsx"
    },
    {
      "path": "vibes/soul/form/dynamic-form/schema.ts",
      "content": "import { z } from 'zod';\n\ninterface FormField {\n  name: string;\n  label?: string;\n  errors?: string[];\n  required?: boolean;\n  id?: string;\n  placeholder?: string;\n}\n\ntype RadioField = {\n  type: 'radio-group';\n  options: Array<{ label: string; value: string }>;\n  defaultValue?: string;\n} & FormField;\n\ntype SelectField = {\n  type: 'select';\n  options: Array<{ label: string; value: string }>;\n  defaultValue?: string;\n} & FormField;\n\ntype CheckboxField = {\n  type: 'checkbox';\n  defaultValue?: string;\n} & FormField;\n\ntype CheckboxGroupField = {\n  type: 'checkbox-group';\n  options: Array<{ label: string; value: string }>;\n  defaultValue?: string[];\n} & FormField;\n\ntype NumberInputField = {\n  type: 'number';\n  defaultValue?: string;\n  min?: number;\n  max?: number;\n  step?: number;\n  incrementLabel?: string;\n  decrementLabel?: string;\n} & FormField;\n\ntype TextInputField = {\n  type: 'text';\n  defaultValue?: string;\n} & FormField;\n\ntype EmailInputField = {\n  type: 'email';\n  defaultValue?: string;\n} & FormField;\n\ntype TextAreaField = {\n  type: 'textarea';\n  defaultValue?: string;\n} & FormField;\n\ntype DateField = {\n  type: 'date';\n  defaultValue?: string;\n  minDate?: string;\n  maxDate?: string;\n} & FormField;\n\ntype SwatchRadioFieldOption =\n  | {\n      type: 'color';\n      value: string;\n      label: string;\n      color: string;\n      disabled?: boolean;\n    }\n  | {\n      type: 'image';\n      value: string;\n      label: string;\n      image: { src: string; alt: string };\n      disabled?: boolean;\n    };\n\ntype SwatchRadioField = {\n  type: 'swatch-radio-group';\n  defaultValue?: string;\n  options: SwatchRadioFieldOption[];\n} & FormField;\n\ntype CardRadioField = {\n  type: 'card-radio-group';\n  defaultValue?: string;\n  options: Array<{\n    value: string;\n    label: string;\n    image: { src: string; alt: string };\n    disabled?: boolean;\n  }>;\n} & FormField;\n\ntype ButtonRadioField = {\n  type: 'button-radio-group';\n  defaultValue?: string;\n  pattern?: string;\n  options: Array<{\n    value: string;\n    label: string;\n    disabled?: boolean;\n  }>;\n} & FormField;\n\ntype PasswordField = {\n  type: 'password';\n} & FormField;\n\ntype ConfirmPasswordField = {\n  type: 'confirm-password';\n} & FormField;\n\ntype HiddenInputField = {\n  type: 'hidden';\n  defaultValue?: string;\n} & FormField;\n\nexport type Field =\n  | RadioField\n  | CheckboxField\n  | CheckboxGroupField\n  | NumberInputField\n  | TextInputField\n  | TextAreaField\n  | DateField\n  | SwatchRadioField\n  | CardRadioField\n  | ButtonRadioField\n  | SelectField\n  | PasswordField\n  | ConfirmPasswordField\n  | EmailInputField\n  | HiddenInputField;\n\nexport type FieldGroup<F> = F[];\n\nexport type SchemaRawShape = Record<\n  string,\n  | z.ZodString\n  | z.ZodOptional<z.ZodString>\n  | z.ZodNumber\n  | z.ZodOptional<z.ZodNumber>\n  | z.ZodArray<z.ZodString>\n  | z.ZodOptional<z.ZodArray<z.ZodString>>\n>;\n\nfunction getFieldSchema(field: Field) {\n  let fieldSchema:\n    | z.ZodString\n    | z.ZodNumber\n    | z.ZodOptional<z.ZodString>\n    | z.ZodOptional<z.ZodNumber>\n    | z.ZodArray<z.ZodString, 'atleastone' | 'many'>\n    | z.ZodOptional<z.ZodArray<z.ZodString, 'atleastone' | 'many'>>;\n\n  switch (field.type) {\n    case 'number':\n      fieldSchema = z.number();\n\n      if (field.min != null) fieldSchema = fieldSchema.min(field.min);\n      if (field.max != null) fieldSchema = fieldSchema.max(field.max);\n      if (field.required !== true) fieldSchema = fieldSchema.optional();\n\n      break;\n\n    case 'password':\n      fieldSchema = z\n        .string()\n        .min(8, { message: 'Be at least 8 characters long' })\n        .regex(/[a-zA-Z]/, { message: 'Contain at least one letter.' })\n        .regex(/[0-9]/, { message: 'Contain at least one number.' })\n        .regex(/[^a-zA-Z0-9]/, {\n          message: 'Contain at least one special character.',\n        })\n        .trim();\n\n      if (field.required !== true) fieldSchema = fieldSchema.optional();\n\n      break;\n\n    case 'email':\n      fieldSchema = z.string().email({ message: 'Please enter a valid email.' }).trim();\n\n      if (field.required !== true) fieldSchema = fieldSchema.optional();\n\n      break;\n\n    case 'checkbox-group':\n      fieldSchema = z.string().array();\n\n      if (field.required === true) fieldSchema = fieldSchema.nonempty();\n\n      break;\n\n    default:\n      fieldSchema = z.string();\n\n      if (field.required !== true) fieldSchema = fieldSchema.optional();\n  }\n\n  return fieldSchema;\n}\n\nexport function schema(fields: Array<Field | FieldGroup<Field>>) {\n  const shape: SchemaRawShape = {};\n  let passwordFieldName: string | undefined;\n  let confirmPasswordFieldName: string | undefined;\n\n  fields.forEach((field) => {\n    if (Array.isArray(field)) {\n      field.forEach((f) => {\n        shape[f.name] = getFieldSchema(f);\n\n        if (f.type === 'password') passwordFieldName = f.name;\n        if (f.type === 'confirm-password') confirmPasswordFieldName = f.name;\n      });\n    } else {\n      shape[field.name] = getFieldSchema(field);\n\n      if (field.type === 'password') passwordFieldName = field.name;\n      if (field.type === 'confirm-password') confirmPasswordFieldName = field.name;\n    }\n  });\n\n  return z.object(shape).superRefine((data, ctx) => {\n    if (\n      passwordFieldName != null &&\n      confirmPasswordFieldName != null &&\n      data[passwordFieldName] !== data[confirmPasswordFieldName]\n    ) {\n      ctx.addIssue({\n        code: 'custom',\n        message: 'The passwords did not match',\n        path: [confirmPasswordFieldName],\n      });\n    }\n  });\n}\n",
      "type": "registry:ui",
      "target": "vibes/soul/form/dynamic-form/schema.ts"
    }
  ]
}